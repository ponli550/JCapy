
You are the **jcapy Project Cartographer**. Analyze the provided code context and identify 5 high-value patterns, utilities, or architectural decisions that fit the "One-Army" philosophy.

### Goal:
Extract reusable "Skills" that enable a single developer to manage complex systems.

### Output Requirements:
Return a Markdown document with:
1. **Title**: Name of the pattern.
2. **Category**: (ui, backend, devops, logic)
3. **Rationale**: Why this is a "One-Army" win.
4. **Source**: The exact file path.

--- PROJECT CONTEXT ---

--- FILE: ./tests/test_feedback.py ---
"""Tests for the feedback module (spinners, progress bars, banners)."""
import pytest
from unittest.mock import patch, MagicMock
from jcapy.ui.ux import feedback


class TestWithSpinner:
    """Tests for the with_spinner decorator."""

    def test_spinner_decorator_calls_function(self):
        """Verify decorated function is called and returns result."""
        @feedback.with_spinner("Testing...")
        def sample_func():
            return "success"

        result = sample_func()
        assert result == "success"

    def test_spinner_in_quiet_mode_skips_output(self):
        """Verify spinner is skipped in quiet mode."""
        feedback.set_quiet_mode(True)
        try:
            @feedback.with_spinner("Should not show")
            def sample_func():
                return "done"

            result = sample_func()
            assert result == "done"
        finally:
            feedback.set_quiet_mode(False)


class TestProgressBar:
    """Tests for the progress_bar conte

--- FILE: ./tests/test_hints.py ---
"""Tests for the hints module (typo suggestions, tutorial)."""
import pytest
import os
import json
import tempfile
from unittest.mock import patch
from jcapy.ui.ux.hints import suggest_command, show_hint, Tutorial, JCAPY_COMMANDS


class TestSuggestCommand:
    """Tests for the suggest_command function."""

    def test_exact_match_not_suggested(self):
        """Verify exact matches return empty (no suggestion needed)."""
        # For exact matches, difflib won't suggest since it's already correct
        # But our function will return it as a close match
        commands = ["deploy", "delete", "doctor"]
        suggestions = suggest_command("deploy", commands)
        assert "deploy" in suggestions

    def test_typo_suggests_correct_command(self):
        """Verify typos suggest the correct command."""
        commands = ["deploy", "delete", "doctor"]

        suggestions = suggest_command("delpoy", commands)
        assert "deploy" in suggestions

        suggestions = suggest_com

--- FILE: ./tests/test_safety.py ---
"""Tests for the safety module (undo stack, confirmations)."""
import pytest
import os
import tempfile
import shutil
from unittest.mock import patch
from jcapy.ui.ux.safety import UndoStack, confirm, require_dependency


class TestUndoStack:
    """Tests for the UndoStack class."""

    @pytest.fixture
    def temp_undo_dir(self, tmp_path):
        """Create a temporary undo directory."""
        undo_dir = tmp_path / "undo"
        undo_dir.mkdir()
        return str(undo_dir)

    @pytest.fixture
    def test_file(self, tmp_path):
        """Create a test file for backup."""
        test_file = tmp_path / "test_skill.md"
        test_file.write_text("# Test Skill\nContent here")
        return str(test_file)

    def test_push_creates_backup(self, temp_undo_dir, test_file):
        """Verify push creates a backup file."""
        with patch('jcapy.ui.ux.safety.UNDO_DIR', temp_undo_dir):
            with patch('jcapy.ui.ux.safety.UNDO_MANIFEST', os.path.join(temp_undo_dir, 'manifest.j

--- FILE: ./tests/__init__.py ---


--- FILE: ./tests/test_a11y.py ---
"""Tests for the a11y module (themes, screen reader, reduced motion)."""
import pytest
import os
from unittest.mock import patch
from jcapy.ui.ux.a11y import (
    THEMES, set_theme, get_theme, get_color,
    is_reduced_motion, format_for_screen_reader, get_spinner_style
)


class TestThemes:
    """Tests for theme management."""

    def test_default_theme_exists(self):
        """Verify default theme is defined."""
        assert "default" in THEMES
        assert "primary" in THEMES["default"]

    def test_high_contrast_theme_exists(self):
        """Verify high-contrast theme is defined."""
        assert "high-contrast" in THEMES
        assert "primary" in THEMES["high-contrast"]

    def test_monochrome_theme_exists(self):
        """Verify monochrome theme is defined."""
        assert "monochrome" in THEMES

    def test_set_theme_valid(self):
        """Verify setting a valid theme works."""
        original = get_theme()
        try:
            result = set_theme("high-con

--- FILE: ./docs/USER_WORKFLOW.md ---
# JCapy User Workflow: Building a Project

## Overview
This document illustrates the complete user journey when building a project using JCapy CLI commands.

---

## Terminology Reference

| JCapy Term | Industry Standard | Description |
|------------|-------------------|-------------|
| Framework | Template/Scaffold | Reusable code pattern with executable steps |
| Library | Knowledge Base | Collection of frameworks organized by domain |
| Persona | Workspace/Profile | Isolated environment with custom library |
| Harvest | Capture Pattern | Extract reusable code into a framework |
| Apply | Deploy Template | Inject framework code into current project |
| Brain | Repository | Personal or shared framework storage |

---

## User Workflow Diagram

```mermaid
flowchart TD
    subgraph SETUP["ðŸš€ Setup Phase"]
        A[Developer starts new project] --> B[jcapy init]
        B --> C{Select Grade}
        C -->|A: Production| D[Full CI/CD, Tests, Security]
        C -->|B: Staging| E[Docker, 

--- FILE: ./docs/INSTALLATION.md ---
# JCapy Installation Guide

## Quick Install

### Option 1: Homebrew (macOS - Recommended)
```bash
brew tap ponli550/jcapy
brew install jcapy
jcapy help
```

### Option 2: pip/pipx
```bash
pipx install jcapy
# or
pip install jcapy
jcapy help
```

---

## Troubleshooting

### "ModuleNotFoundError: No module named 'jcapy'"

**Cause:** Multiple jcapy installations conflict. A dev `.venv` version may be overriding the system install.

**Fix:**
```bash
# Check which jcapy is being used
which jcapy

# If it shows .venv path, deactivate or use absolute path:
deactivate  # if in venv
hash -r     # refresh shell PATH cache

# Or use Homebrew version directly:
/opt/homebrew/bin/jcapy help
```

### Removing Conflicting Installations
```bash
# Remove pipx version
pipx uninstall jcapy

# Remove pip version
pip uninstall jcapy

# Remove .venv (if in dev directory)
rm -rf .venv/bin/jcapy

# Verify only Homebrew remains
which -a jcapy
# Should show: /opt/homebrew/bin/jcapy
```

---

## For Developers


--- FILE: ./docs/plans/2026-02-11-gap-analysis-jcapy-vs-dataiku.md ---
# JCapy vs Dataiku â€” Gap Analysis

> **Purpose**: Honest assessment of how JCapy compares to Dataiku, what's actually comparable vs what's not, and what (if anything) is worth borrowing.

---

## TL;DR Verdict

**These are not competitors. They exist in completely different universes.**

Dataiku is a **$2.4B enterprise AI platform** serving Fortune 500 companies at â‚¬50Kâ€“â‚¬250K/year. JCapy is a **free, CLI-based developer knowledge tool** built by one person for one person. Comparing them is like comparing a Swiss Army knife to an aircraft carrier â€” both are useful, neither replaces the other.

The real question isn't "how far is the gap" â€” it's **"what ideas from Dataiku's architecture could make JCapy smarter without bloating it?"**

---

## What Dataiku Actually Is

| Dimension | Dataiku |
|---|---|
| **Category** | Enterprise AI/ML Platform (Gartner Magic Quadrant Leader) |
| **Team** | ~1,800 employees, $400M+ raised |
| **Pricing** | â‚¬50Kâ€“â‚¬250K/year enterprise licenses |
| **Users*

--- FILE: ./docs/plans/2026-02-10-gap-analysis-jcapy-vs-clawdbot.md ---
# JCapy vs Clawdbot (OpenClaw) â€” Gap Analysis

> **Purpose**: Honest assessment of where JCapy stands relative to Clawdbot/OpenClaw, what's unique to JCapy, and what gaps matter most for a solo developer.

---

## TL;DR Verdict

**They're solving different problems.** Clawdbot is a *personal AI assistant gateway* (chat â†’ action). JCapy is a *developer knowledge orchestrator* (skill library â†’ project scaffolding). The "gap" isn't about catching up â€” it's about deciding which Clawdbot ideas are worth stealing.

---

## Feature Comparison Matrix

| Capability | JCapy | Clawdbot | Gap Severity |
|---|---|---|---|
| **CLI Interface** | âœ… Python argparse + Rich TUI | âœ… Node.js CLI | â€”  |
| **Skill/Framework System** | âœ… Markdown-based, harvest/apply/merge | âœ… Markdown SKILL.md + marketplace | ðŸŸ¡ Medium |
| **Persona System** | âœ… Multi-persona with Git-backed libraries | âŒ Single identity | **JCapy wins** |
| **Project Scaffolding** | âœ… Grade-aware init + deploy pipeline | âŒ Not a project tool

--- FILE: ./docs/plans/2026-02-11-jcapy-knowledge-lakehouse-design.md ---
# JCapy Knowledge Architecture â€” The Lakehouse Lens

> **Purpose**: Compare JCapy's knowledge storage architecture to the Data Warehouse / Data Lake / Data Lakehouse paradigms. Map the analogy, identify feature gaps, and quantify the improvement of a Lakehouse-inspired redesign.

---

## Angle 1: JCapy as a Data Architecture Analogy

### Where JCapy Sits Today

JCapy's current knowledge system maps almost exactly to the **Data Warehouse** model:

```mermaid
graph TB
    subgraph "JCapy Today = Data Warehouse Model"
        A["Raw Knowledge<br/>(Docs, tutorials, blogs)"] -->|"jcapy harvest<br/>(Manual ETL)"| B["Structured Skills<br/>(.md with YAML frontmatter)"]
        B --> C["Domain Folders<br/>(devops/, docs/, misc/)"]
        C --> D["jcapy list / search<br/>(BI / Reports)"]
        C --> E["jcapy apply<br/>(Execution)"]
    end
```

| Data Warehouse Trait | JCapy Equivalent | Evidence |
|---|---|---|
| **Structured data only** | Skills must follow YAML frontmatter + markdown templ

--- FILE: ./docs/plans/2026-02-09-ux-enhancement.md ---
# JCapy UI/UX Enhancement Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement a centralized UX module providing visual feedback, error recovery, discoverability, and accessibility features for JCapy CLI.

**Architecture:** Create `ui/ux/` subpackage with 4 modules (`feedback.py`, `safety.py`, `hints.py`, `a11y.py`) plus shared config. Commands import UX helpers; all preferences stored in `~/.jcapyrc`.

**Tech Stack:** Python 3.11+, Rich (already dependency), curses (stdlib), difflib (stdlib for typo matching)

---

## Proposed Changes

### UX Module Foundation

#### [NEW] `src/jcapy/ui/ux/__init__.py`
Package init exporting public API.

#### [NEW] `src/jcapy/ui/ux/feedback.py`
- `with_spinner(message)` decorator for slow operations
- `progress_bar(title, total)` context manager
- `show_success/error/warning(msg, hint=None)` banner functions
- Respects `--quiet` flag and `reduced_motion` con

--- FILE: ./scripts/setup.sh ---
#!/bin/bash
set -e

# jcapy Development Setup
# Usage: ./scripts/setup.sh

echo "ðŸš€ JCapy Development Setup"
echo "--------------------------------"

# 1. Check Python Version
PYTHON_VERSION=$(python3 --version 2>&1 | cut -d' ' -f2)
echo "ðŸ“¦ Python Version: $PYTHON_VERSION"

# 2. Create Virtual Environment (optional)
if [ ! -d ".venv" ]; then
    echo "ðŸ“¦ Creating virtual environment..."
    python3 -m venv .venv
    echo "âœ… Virtual environment created at .venv"
fi

# 3. Activate Virtual Environment
echo "ðŸ”§ Activating virtual environment..."
source .venv/bin/activate

# 4. Install in Development Mode
echo "ðŸ“¦ Installing jcapy in development mode..."
pip install -e .

# 5. Install Rich Dependency
pip install rich

# 6. Verify Installation
echo ""
echo "ðŸ§ª Verifying installation..."
which jcapy
jcapy help

echo ""
echo "âœ… Setup Complete!"
echo "--------------------------------"
echo "To use jcapy, activate the venv first:"
echo "  source .venv/bin/activate"
echo ""
echo "Then run:"
echo "  jc

--- FILE: ./scripts/publishPip.sh ---
#!/bin/bash
set -e

# jcapy PyPI Release Automation
# Usage: ./scripts/publishPip.sh
#
# Features:
# - Auto-creates virtual environment if needed
# - Pre-commit pending changes
# - Version bump (patch/minor/major)
# - Git tag + push
# - Build wheel + sdist
# - Upload to PyPI (TestPyPI or Production)

echo "ðŸ jcapy PyPI Release Protocol"
echo "================================"

cd "$(dirname "$0")/.."
GITHUB_USER="ponli550"
REPO_NAME="JCapy"

# ==========================================
# PHASE 0a: Virtual Environment Check
# ==========================================

if [ -z "$VIRTUAL_ENV" ]; then
    echo ""
    echo "ðŸ”§ No virtual environment detected."

    if [ -d "venv" ]; then
        echo "   Found existing venv/ directory."
        echo "   Activating..."
        source venv/bin/activate
        echo "   âœ” Activated: $VIRTUAL_ENV"
    else
        echo "   Creating new virtual environment..."
        python3 -m venv venv
        source venv/bin/activate
        echo "   âœ” Creat

--- FILE: ./scripts/publish.sh ---
#!/bin/bash
set -e

# ============================================================================
# jcapy Combined Release Automation (Secure Edition)
# ============================================================================
# Usage: ./scripts/publish.sh [OPTIONS]
#
# Options:
#   --dry-run    Preview all commands without executing
#   --force      Skip confirmation prompts (use with caution)
#
# Flow: Pip-First, Homebrew Opt-In
#   Phase 0a: Virtual Environment Setup (upfront)
#   Phase 0b: Security Checks (branch, clean tree, remote, version)
#   Phase 0c: PyPI Credential Check (fail fast)
#   Phase 1:  Pre-Commit Pending Changes
#   Phase 2:  Version Bump
#   Phase 3:  Tag & Push
#   Phase 4:  PyPI Build & Upload (default path)
#   Phase 5:  Homebrew Update (opt-in)
#   Phase 6:  Summary
# ============================================================================

echo "ðŸš€ jcapy Release Protocol (Secure Edition)"
echo "============================================"

cd "$(dirn

--- FILE: ./scripts/publishBrew.sh ---
#!/bin/bash
set -e

# jcapy Release Automation (Complete Edition)
# Usage: ./scripts/publish.sh
#
# Features:
# - First-time GitHub repo setup
# - Pre-commit pending changes
# - Version bump (patch/minor/major)
# - Git tag + push
# - Homebrew tap update

echo "ðŸš€ jcapy Release Protocol"
echo "================================"

cd "$(dirname "$0")/.."
REPO_NAME="homebrew-JCapy"
GITHUB_USER="ponli550"

# ==========================================
# PHASE 0: First-Time Setup Check
# ==========================================

# Check if gh CLI is available (optional but recommended)
HAS_GH=false
if command -v gh &> /dev/null; then
    HAS_GH=true
fi

# Check if remote exists
if ! git remote get-url origin &> /dev/null; then
    echo "âš ï¸  No remote 'origin' configured."
    echo ""

    if $HAS_GH; then
        echo "ðŸ”§ GitHub CLI detected. Setting up..."

        # Check if repo exists on GitHub
        if gh repo view "$GITHUB_USER/$REPO_NAME" &> /dev/null; then
            echo "ðŸ“¦ Found e

--- FILE: ./venv/lib/python3.14/site-packages/mdurl/_decode.py ---
from __future__ import annotations

from collections.abc import Sequence
import functools
import re

DECODE_DEFAULT_CHARS = ";/?:@&=+$,#"
DECODE_COMPONENT_CHARS = ""

decode_cache: dict[str, list[str]] = {}


def get_decode_cache(exclude: str) -> Sequence[str]:
    if exclude in decode_cache:
        return decode_cache[exclude]

    cache: list[str] = []
    decode_cache[exclude] = cache

    for i in range(128):
        ch = chr(i)
        cache.append(ch)

    for i in range(len(exclude)):
        ch_code = ord(exclude[i])
        cache[ch_code] = "%" + ("0" + hex(ch_code)[2:].upper())[-2:]

    return cache


# Decode percent-encoded string.
#
def decode(string: str, exclude: str = DECODE_DEFAULT_CHARS) -> str:
    cache = get_decode_cache(exclude)
    repl_func = functools.partial(repl_func_with_cache, cache=cache)
    return re.sub(r"(%[a-f0-9]{2})+", repl_func, string, flags=re.IGNORECASE)


def repl_func_with_cache(match: re.Match, cache: Sequence[str]) -> str:
    seq = match.

--- FILE: ./venv/lib/python3.14/site-packages/mdurl/_url.py ---
from __future__ import annotations

from typing import NamedTuple


class URL(NamedTuple):
    protocol: str | None
    slashes: bool
    auth: str | None
    port: str | None
    hostname: str | None
    hash: str | None  # noqa: A003
    search: str | None
    pathname: str | None


--- FILE: ./venv/lib/python3.14/site-packages/mdurl/__init__.py ---
__all__ = (
    "decode",
    "DECODE_DEFAULT_CHARS",
    "DECODE_COMPONENT_CHARS",
    "encode",
    "ENCODE_DEFAULT_CHARS",
    "ENCODE_COMPONENT_CHARS",
    "format",
    "parse",
    "URL",
)
__version__ = "0.1.2"  # DO NOT EDIT THIS LINE MANUALLY. LET bump2version UTILITY DO IT

from mdurl._decode import DECODE_COMPONENT_CHARS, DECODE_DEFAULT_CHARS, decode
from mdurl._encode import ENCODE_COMPONENT_CHARS, ENCODE_DEFAULT_CHARS, encode
from mdurl._format import format
from mdurl._parse import url_parse as parse
from mdurl._url import URL


--- FILE: ./venv/lib/python3.14/site-packages/mdurl/_format.py ---
from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from mdurl._url import URL


def format(url: URL) -> str:  # noqa: A001
    result = ""

    result += url.protocol or ""
    result += "//" if url.slashes else ""
    result += url.auth + "@" if url.auth else ""

    if url.hostname and ":" in url.hostname:
        # ipv6 address
        result += "[" + url.hostname + "]"
    else:
        result += url.hostname or ""

    result += ":" + url.port if url.port else ""
    result += url.pathname or ""
    result += url.search or ""
    result += url.hash or ""

    return result


--- FILE: ./venv/lib/python3.14/site-packages/mdurl/_parse.py ---
# Copyright Joyent, Inc. and other Node contributors.
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to permit
# persons to whom the Software is furnished to do so, subject to the
# following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
# NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
# DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
# OT

--- FILE: ./venv/lib/python3.14/site-packages/mdurl/_encode.py ---
from __future__ import annotations

from collections.abc import Sequence
from string import ascii_letters, digits, hexdigits
from urllib.parse import quote as encode_uri_component

ASCII_LETTERS_AND_DIGITS = ascii_letters + digits

ENCODE_DEFAULT_CHARS = ";/?:@&=+$,-_.!~*'()#"
ENCODE_COMPONENT_CHARS = "-_.!~*'()"

encode_cache: dict[str, list[str]] = {}


# Create a lookup array where anything but characters in `chars` string
# and alphanumeric chars is percent-encoded.
def get_encode_cache(exclude: str) -> Sequence[str]:
    if exclude in encode_cache:
        return encode_cache[exclude]

    cache: list[str] = []
    encode_cache[exclude] = cache

    for i in range(128):
        ch = chr(i)

        if ch in ASCII_LETTERS_AND_DIGITS:
            # always allow unencoded alphanumeric characters
            cache.append(ch)
        else:
            cache.append("%" + ("0" + hex(i)[2:].upper())[-2:])

    for i in range(len(exclude)):
        cache[ord(exclude[i])] = exclude[i]

    

--- FILE: ./venv/lib/python3.14/site-packages/packaging/tags.py ---
# This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.

from __future__ import annotations

import logging
import platform
import re
import struct
import subprocess
import sys
import sysconfig
from importlib.machinery import EXTENSION_SUFFIXES
from typing import (
    Any,
    Iterable,
    Iterator,
    Sequence,
    Tuple,
    cast,
)

from . import _manylinux, _musllinux

logger = logging.getLogger(__name__)

PythonVersion = Sequence[int]
AppleVersion = Tuple[int, int]

INTERPRETER_SHORT_NAMES: dict[str, str] = {
    "python": "py",  # Generic.
    "cpython": "cp",
    "pypy": "pp",
    "ironpython": "ip",
    "jython": "jy",
}


_32_BIT_INTERPRETER = struct.calcsize("P") == 4


class Tag:
    """
    A representation of the tag triple for a wheel.

    Instances are considered immutable and thus are hashable. Equality checking
    is also supported.
    """



--- FILE: ./venv/lib/python3.14/site-packages/packaging/_musllinux.py ---
"""PEP 656 support.

This module implements logic to detect if the currently running Python is
linked against musl, and what musl version is used.
"""

from __future__ import annotations

import functools
import re
import subprocess
import sys
from typing import Iterator, NamedTuple, Sequence

from ._elffile import ELFFile


class _MuslVersion(NamedTuple):
    major: int
    minor: int


def _parse_musl_version(output: str) -> _MuslVersion | None:
    lines = [n for n in (n.strip() for n in output.splitlines()) if n]
    if len(lines) < 2 or lines[0][:4] != "musl":
        return None
    m = re.match(r"Version (\d+)\.(\d+)", lines[1])
    if not m:
        return None
    return _MuslVersion(major=int(m.group(1)), minor=int(m.group(2)))


@functools.lru_cache
def _get_musl_version(executable: str) -> _MuslVersion | None:
    """Detect currently-running musl runtime version.

    This is done by checking the specified executable's dynamic linking
    information, and invoking the loade

--- FILE: ./venv/lib/python3.14/site-packages/packaging/metadata.py ---
from __future__ import annotations

import email.feedparser
import email.header
import email.message
import email.parser
import email.policy
import keyword
import pathlib
import sys
import typing
from typing import (
    Any,
    Callable,
    Generic,
    Literal,
    TypedDict,
    cast,
)

from . import licenses, requirements, specifiers, utils
from . import version as version_module

if typing.TYPE_CHECKING:
    from .licenses import NormalizedLicenseExpression

T = typing.TypeVar("T")


if sys.version_info >= (3, 11):  # pragma: no cover
    ExceptionGroup = ExceptionGroup  # noqa: F821
else:  # pragma: no cover

    class ExceptionGroup(Exception):
        """A minimal implementation of :external:exc:`ExceptionGroup` from Python 3.11.

        If :external:exc:`ExceptionGroup` is already defined by Python itself,
        that version is used instead.
        """

        message: str
        exceptions: list[Exception]

        def __init__(self, message: str, exceptions: list[Ex

--- FILE: ./venv/lib/python3.14/site-packages/packaging/version.py ---
# This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.
"""
.. testsetup::

    from packaging.version import parse, Version
"""

from __future__ import annotations

import re
import sys
import typing
from typing import (
    Any,
    Callable,
    Literal,
    NamedTuple,
    SupportsInt,
    Tuple,
    TypedDict,
    Union,
)

from ._structures import Infinity, InfinityType, NegativeInfinity, NegativeInfinityType

if typing.TYPE_CHECKING:
    from typing_extensions import Self, Unpack

if sys.version_info >= (3, 13):  # pragma: no cover
    from warnings import deprecated as _deprecated
elif typing.TYPE_CHECKING:
    from typing_extensions import deprecated as _deprecated
else:  # pragma: no cover
    import functools
    import warnings

    def _deprecated(message: str) -> object:
        def decorator(func: object) -> object:
            @functools.wraps(func

--- FILE: ./venv/lib/python3.14/site-packages/packaging/pylock.py ---
from __future__ import annotations

import dataclasses
import logging
import re
from collections.abc import Mapping, Sequence
from dataclasses import dataclass
from datetime import datetime
from typing import (
    TYPE_CHECKING,
    Any,
    Callable,
    Protocol,
    TypeVar,
)

from .markers import Marker
from .specifiers import SpecifierSet
from .utils import NormalizedName, is_normalized_name
from .version import Version

if TYPE_CHECKING:  # pragma: no cover
    from pathlib import Path

    from typing_extensions import Self

_logger = logging.getLogger(__name__)

__all__ = [
    "Package",
    "PackageArchive",
    "PackageDirectory",
    "PackageSdist",
    "PackageVcs",
    "PackageWheel",
    "Pylock",
    "PylockUnsupportedVersionError",
    "PylockValidationError",
    "is_valid_pylock_path",
]

_T = TypeVar("_T")
_T2 = TypeVar("_T2")


class _FromMappingProtocol(Protocol):  # pragma: no cover
    @classmethod
    def _from_dict(cls, d: Mapping[str, Any]) -> Self: ...


_

--- FILE: ./venv/lib/python3.14/site-packages/packaging/__init__.py ---
# This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.

__title__ = "packaging"
__summary__ = "Core utilities for Python packages"
__uri__ = "https://github.com/pypa/packaging"

__version__ = "26.0"

__author__ = "Donald Stufft and individual contributors"
__email__ = "donald@stufft.io"

__license__ = "BSD-2-Clause or Apache-2.0"
__copyright__ = f"2014 {__author__}"


--- FILE: ./venv/lib/python3.14/site-packages/packaging/_parser.py ---
"""Handwritten parser of dependency specifiers.

The docstring for each __parse_* function contains EBNF-inspired grammar representing
the implementation.
"""

from __future__ import annotations

import ast
from typing import List, Literal, NamedTuple, Sequence, Tuple, Union

from ._tokenizer import DEFAULT_RULES, Tokenizer


class Node:
    __slots__ = ("value",)

    def __init__(self, value: str) -> None:
        self.value = value

    def __str__(self) -> str:
        return self.value

    def __repr__(self) -> str:
        return f"<{self.__class__.__name__}({self.value!r})>"

    def serialize(self) -> str:
        raise NotImplementedError


class Variable(Node):
    __slots__ = ()

    def serialize(self) -> str:
        return str(self)


class Value(Node):
    __slots__ = ()

    def serialize(self) -> str:
        return f'"{self}"'


class Op(Node):
    __slots__ = ()

    def serialize(self) -> str:
        return str(self)


MarkerLogical = Literal["and", "or"]
MarkerVa

--- FILE: ./venv/lib/python3.14/site-packages/packaging/utils.py ---
# This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.

from __future__ import annotations

import re
from typing import NewType, Tuple, Union, cast

from .tags import Tag, parse_tag
from .version import InvalidVersion, Version, _TrimmedRelease

BuildTag = Union[Tuple[()], Tuple[int, str]]
NormalizedName = NewType("NormalizedName", str)


class InvalidName(ValueError):
    """
    An invalid distribution name; users should refer to the packaging user guide.
    """


class InvalidWheelFilename(ValueError):
    """
    An invalid wheel filename was found, users should refer to PEP 427.
    """


class InvalidSdistFilename(ValueError):
    """
    An invalid sdist filename was found, users should refer to the packaging user guide.
    """


# Core metadata spec for `Name`
_validate_regex = re.compile(r"[A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9]", re.IGNORECASE)
_normali

--- FILE: ./venv/lib/python3.14/site-packages/packaging/requirements.py ---
# This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.
from __future__ import annotations

from typing import Iterator

from ._parser import parse_requirement as _parse_requirement
from ._tokenizer import ParserSyntaxError
from .markers import Marker, _normalize_extra_values
from .specifiers import SpecifierSet
from .utils import canonicalize_name


class InvalidRequirement(ValueError):
    """
    An invalid requirement was found, users should refer to PEP 508.
    """


class Requirement:
    """Parse a requirement.

    Parse a given requirement string into its parts, such as name, specifier,
    URL, and extras. Raises InvalidRequirement on a badly-formed requirement
    string.
    """

    # TODO: Can we test whether something is contained within a requirement?
    #       If so how do we do that? Do we need to test against the _name_ of
    #       the thi

--- FILE: ./venv/lib/python3.14/site-packages/packaging/_structures.py ---
# This file is dual licensed under the terms of the Apache License, Version
# 2.0, and the BSD License. See the LICENSE file in the root of this repository
# for complete details.

import typing


@typing.final
class InfinityType:
    __slots__ = ()

    def __repr__(self) -> str:
        return "Infinity"

    def __hash__(self) -> int:
        return hash(repr(self))

    def __lt__(self, other: object) -> bool:
        return False

    def __le__(self, other: object) -> bool:
        return False

    def __eq__(self, other: object) -> bool:
        return isinstance(other, self.__class__)

    def __gt__(self, other: object) -> bool:
        return True

    def __ge__(self, other: object) -> bool:
        return True

    def __neg__(self: object) -> "NegativeInfinityType":
        return NegativeInfinity


Infinity = InfinityType()


@typing.final
class NegativeInfinityType:
    __slots__ = ()

    def __repr__(self) -> str:
        return "-Infinity"

    def __hash__(self) -> 

